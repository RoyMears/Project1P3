// Course number: CECS 347
// Assignment number: Project 1 Part 3
// Authors: Roy Mears, Jonathan Ramirez, Nolan Nguyen, Christian Mata
// Date: 09/11/24
// System Requirements:
// (5 points) Project1P3: We add an ultrasonic sensor to Part 2, modifing Part 2 code in the
// following ways: using General Purpose Timer1 in 16-bit count down mode to generate
// trigger pulses and to measure ultrasonic echo high period. We will need to adjust the
// prescale value so that the maximum time duration generated by timer1 is slightly greater
// than the maximum echo pulse width. Edge interrupt is required to capture the rising
// edge and the falling edge of the echo pin. We simulate and screen shot the logic
// analyzer outputs with the grid set to be 10us. Demonstrate onboard in debug mode with
// the right break point and show three different distances: <10cm, [70cm, 100cm] and
// between [10cm, 70cm].

// 0.Documentation Section
// Project1P2.c
// Runs on TM4C123
// Ultrasonic sensor HC-SR04
// Timer 1 in 16 bit  countdown mode
// PLL for 16Mhz system clock
// PB6 connected to 3.3v from Echo Pin
// PB7 connected to Trigger Pin
// Onboard 5v VBUS connected to HC-SR01 VCC
// Ground connected to HC-SR01 Gnd



#include "tm4c123gh6pm.h"
#include "Timer1A.h" 	// for trigger pulses and echo measuring
#include "PLL.h"			// for 16Mhz clock
#include <stdint.h> 	// for data type alias

#define TRIGGER_PIN 		(*((volatile unsigned long *)0x40005200))  // PB7 is the trigger pin	
#define TRIGGER_VALUE 	0x80   // trigger at bit 7

#define ECHO_PIN 				(*((volatile unsigned long *)0x40005100))  // PB6 is the echo pin	
#define ECHO_VALUE 			0x40   // trigger at bit 6

#define MC_LEN 					0.0625 // length of one machine cycle in microsecond for 16MHz clock
#define SOUND_SPEED 		0.0343 // centimeter per micro-second
#define PortB6Mask 			0x40
extern void EnableInterrupts(void);
extern void GPIOPortB_Handler(void);

void PortB_Init(void);
static volatile uint8_t done = 0;
static volatile uint32_t distance = 0;


int main(void){
	PortB_Init();
	Timer1A_Init();
  EnableInterrupts();
  while(1){
		done = 0;
		distance = 0;
		TRIGGER_PIN &= ~TRIGGER_VALUE; // send low to trigger
		Timer1A_Start( 0, 32 );// use timer to wait 2us
		Timer1A_Stop();
		TRIGGER_PIN |= TRIGGER_VALUE; // send high to trigger
		Timer1A_Start( 0, 160 );// use timer to wait 10us
		Timer1A_Stop();																	
		TRIGGER_PIN &= ~TRIGGER_VALUE; // send low to trigger
		
    while (!done);
  }
}

void PortB_Init(void){ 
  SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOB;           											// 1) activate clock for Port B
	while ((SYSCTL_RCGC2_R&SYSCTL_RCGC2_GPIOB)!=SYSCTL_RCGC2_GPIOB){}; 		// wait for clock to start
  GPIO_PORTB_PCTL_R &= ~0x0F000000; 																		// 3) configure PB6 for T0CCP0
  GPIO_PORTB_AMSEL_R &= (uint32_t)~0xC0;      													// 4) disable analog function on PA2
  GPIO_PORTB_DIR_R &= ~PortB6Mask;        															// 5) PB6:echo pin, input
  GPIO_PORTB_DIR_R |= 0x80;         																		// 5) PB7:trigger pin, output
  GPIO_PORTB_AFSEL_R &= ~0xC0;     																		  // 6) regular port function
  GPIO_PORTB_DEN_R |= 0xC0;         																		// 7) enable digital port
  GPIO_PORTB_IS_R &= ~PortB6Mask;         															// PB6 is edge-sensitive
  GPIO_PORTB_IBE_R |= PortB6Mask;         															// PB6 is both edges
  GPIO_PORTB_IEV_R &= ~PortB6Mask;        															// PB6 both edge event
  GPIO_PORTB_ICR_R = PortB6Mask;          															// clear flag 6
  GPIO_PORTB_IM_R |= PortB6Mask;          															// arm interrupt on PB6
  NVIC_PRI0_R = (NVIC_PRI0_R&0xFFFF1FFF)|0x00006000; 										// priority 3
  NVIC_EN0_R = 0x00000002;          																		// enable Port B edge interrupt
}


void GPIOPortB_Handler(void){
	
	if (ECHO_PIN==ECHO_VALUE){  // echo pin rising edge is detected, start timing
		Timer1A_Start(99, 5120);
	}
	else { 											
		Timer1A_Stop();
		distance = (uint32_t)(Timer1A_Elapsed()*MC_LEN*SOUND_SPEED)/2;		
		done = 1;
	}
  GPIO_PORTB_ICR_R = 0x40;      // acknowledge flag 6
}
